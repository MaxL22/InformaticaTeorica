% !TeX spellcheck = it_IT
\documentclass[12pt, answers]{exam}

\usepackage[hidelinks]{hyperref}
\usepackage[autostyle, english = american]{csquotes}
\MakeOuterQuote{"}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsthm}
\usepackage{dutchcal}
\usepackage{stmaryrd}
\usepackage[normalem]{ulem}

\title{Domande Informatica Teorica}
\author{Massimo Perego}
\date{}

\theoremstyle{plain}
\newtheorem{theor}{Teorema}[section]
\newtheorem{coroll}{Corollario}[section]

\renewcommand{\proofname}{Dimostrazione}

\DeclareMathOperator{\des}{des}
\DeclareMathOperator{\op}{op}
\DeclareMathOperator{\somma}{somma}
\DeclareMathOperator{\prodotto}{prodotto}
\DeclareMathOperator{\predecessore}{predecessore}
\DeclareMathOperator{\MIN}{MIN}

\renewcommand{\Im}{\text{Im}}
\newcommand{\ImSet}{\text{Im}}
\newcommand{\Dom}{\text{Dom}}
\newcommand{\tc}{\; \text{ t.c. } \;}
\newcommand{\bat}{B^A_\bot}
\newcommand{\dati}{\text{DATI}}
\newcommand{\prog}{\text{PROG}}
\newcommand{\dtime}{\text{DTIME}}
\newcommand{\ftime}{\text{FTIME}}
\newcommand{\dspace}{\text{DSPACE}}
\newcommand{\fspace}{\text{FSPACE}}
\newcommand{\exptime}{\text{EXPTIME}}
\newcommand{\ntime}{\text{NTIME}}
\newcommand{\ram}{\text{RAM}}
\newcommand{\while}{\text{WHILE}}
\newcommand{\for}{\text{FOR}}
\newcommand{\stati}{\text{STATI}}
\newcommand{\elem}{\text{ELEM}}
\newcommand{\elemo}{\text{ELEM}^\Omega}
\newcommand{\wstati}{W\text{-STATI}}
\newcommand{\wcom}{W\text{-COM}}
\newcommand{\wprog}{W\text{-PROG}}
\newcommand{\comp}{\text{Comp}}
\newcommand{\com}{\text{COMP}}
\newcommand{\rp}{\text{RP}}
\newcommand{\pc}{\text{PC}}
\newcommand{\ricprim}{\text{RICPRIM}}
\newcommand{\ric}{\text{RIC}}
\newcommand{\C}{\mathcal{C}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\cp}{\mathcal{P}}
\newcommand{\st}{\mathcal{S}}
\newcommand{\T}{\mathcal{T}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\X}{\mathcal{X}}
\newcommand{\cprog}[1]{\C_{#1}\text{-}\prog}
\newcommand{\proj}{\text{Proj}}
\newcommand{\pro}{\text{Pro}}
\newcommand{\incr}{\text{incr}}
\newcommand{\decr}{\text{decr}}
\newcommand{\sisprog}{\ensuremath{\{\varphi_i\}}}
\newcommand{\fin}{\stackrel{\text{TR}}{=} \text{OK}}
\newcommand{\ar}{\text{AR}}
\newcommand{\arp}{\text{AR}_P}
\newcommand{\arph}{\text{AR}_{\hat{P}}}
\newcommand{\cent}{\text{\textcent}}
\newcommand{\win}{w\text{-}in}
\makeatletter
\newcommand{\dotminus}{\mathbin{\text{\@dotminus}}}

\newcommand{\@dotminus}{%
    \ooalign{\hidewidth\raise1ex\hbox{.}\hidewidth\cr$\m@th-$\cr}%
}
\makeatother

%TODO:
% Cosa si intende con "definire le ricorsive parziali/totali"?
% Come abbiamo definito la potenza computazionale $F(\ram)$.
% Dimostrare che tutte le funzioni $\ricprim$ sono totali.
% Radice quadrata come ricorsiva parziale e whiles
% Proprietà di $\ricprim$; sono totali, come lo dimostreresti?

%%%%% Dal sito
%Teorema di ricorsione con dimostrazione
%differenza tra funzioni totali e funzioni ricorsive totali
%Struttura di una macchina di turing deterministica
%Complessità temporale
%Complessità spaziale
%relazione tra DTIME e NTIME
%la classe degli insiemi riconosciuti dalle macchine di touring coincie con? (la classe dei ricorsivamente numerabili)
%Convincimi del fatto che esistono Quine negli spa
%Enunciato del teorema di ricorsione totale
%Per cosa abbiamo usato il teorema di ricorsione
%Risolvi una funzione con il TR
%Teorema di Rice (enunciato e dimostrazione)
%Cosa dice Rice a proposito di un insieme che rispetta le funzioni
%Il teorema di Rice ci dice quando certi insiemi non sono ricorsivi. Mi fai un esempio di insieme che non rispetta le funzioni? Inventatene uno.
%Questo che hai inventato è ricorsivo?
%Può avere anche altre caratteristiche questo insieme (essere ricorsivamente numerabile o altro?)

\begin{document}
    
    \section*{Domande Informatica Teorica}
    
    \begin{questions}
        \question Cos'è un problema di decisione?
        
        \begin{solution}
            Un problema di decisione è una domanda a cui rispondere \textit{Sì} o \textit{No}. 
            
            Formalmente, è costituito da 3 elementi:
            \begin{itemize}
                \item Nome del problema
                
                \item Istanza degli oggetti considerati
                
                \item Domanda, ovvero proprietà che gli oggetti possono o meno soddisfare
            \end{itemize}
        \end{solution}
        
        \item Come dimostrare l'esistenza di problemi non decidibili, senza mostrarne un esempio?
        
        \begin{solution}
            Per studiare la decidibilità di un problema $\Pi$ ci sono due possibili approcci:
            \begin{itemize}
                \item Trovare un programma $P_\Pi$ che calcola la funzione soluzione
                $$ \Phi_\Pi : D \rightarrow \{0,1\} \tc \Phi_\Pi (x) = \begin{cases}
                    1 & \text{ se } p(x) \\
                    0 & \text{ se } \neg p(x)
                \end{cases}$$
                di conseguenza $\Phi_\Pi \in \T$
                
                \item Se $\Phi_\Pi \in \T$, allora esiste un programma che la calcola
            \end{itemize}
            
            Di conseguenza, i problemi risolvibili $\prog$ sono isomorfi alle funzioni calcolabili, quindi numerabili, mentre tutti i possibili problemi sono rappresentati dalle funzioni da $\N$ a $\N$ (dato quanto già visto), isomorfe a $\N_\bot^\N$, quindi:
            $$ \dati \sim \prog \sim \N \nsim \N_\bot^\N $$
            
            Per dimostrare che $\dati \sim \N$: serve una funzione tale che permetta una biezione tra dati e $\N$, come la funzione coppia di Cantor
            $$ \langle \_, \_ \rangle: \N \times \N \rightarrow \N^+ $$
            (banalmente estendibile a tutto $\N$).
            
            Per dimostrare che $\prog \sim \N$: una volta definito un sistema di calcolo e i relativi comandi, si può mostrare una codifica per questi che porta a una biezione con $\N$.
            
            Alternativamente, un problema di decisione può essere comparato al riconoscimento di un linguaggio $L \subseteq \Sigma^\ast$, per un alfabeto $\Sigma$ di conseguenza: 
            \begin{itemize}
                \item Il numero possibile di linguaggi è $P(\Sigma^\ast) \sim \R$
                
                \item I sistemi di calcolo sono in quantità $\prog \sim \N$
            \end{itemize}
            
            Per forza devono esistere linguaggi non decidibili.
        \end{solution}
        
        \question Il problema dell'arresto: definizione e dimostrazione.
        
        \begin{solution}
            Definizione del problema dell'arresto: 
            \begin{itemize}
                \item Nome: $\ar$
                
                \item Istanza: $x,y \in \N$
                
                \item Domanda: $\varphi_y (x) \downarrow$?
            \end{itemize}
            
            \begin{theor}
                $\ar$ è indecidibile.
            \end{theor}
            \begin{proof}
                Assumiamo per assurdo che $\ar$ sia decidibile, allora esiste una funzione soluzione
                $$
                \Phi_{\ar} (x,y) = \begin{cases}
                    0 & \text{ se } \varphi_y (x) \uparrow \\
                    1 & \text{ se } \varphi_y (x) \downarrow \\
                \end{cases}
                $$
                
                Valutando il caso in cui $x = y$
                $$
                \Phi_{\ar} (x,x) = \begin{cases}
                    0 & \text{ se } \varphi_x (x) \uparrow \\
                    1 & \text{ se } \varphi_x (x) \downarrow \\
                \end{cases}
                $$
                
                Visto che $\Phi_{\ar} \in \T$, anche la funzione
                $$
                f(x) = \begin{cases}
                    0 & \text{ se } \Phi_{\ar} (x) = 0 \equiv \varphi_x (x) \uparrow \\
                    \varphi_x (x) + 1 & \text{ se } \Phi_{\ar} (x) = 1 \equiv \varphi_x (x) \downarrow \\
                \end{cases}
                \in \T
                $$
                
                Sia $\alpha \in \N$ la codifica di $A$ tale che $\varphi_\alpha = f$. Valutiamo $\varphi_\alpha$ in $\alpha$:
                $$
                \varphi_\alpha (\alpha) = \begin{cases}
                    0 & \text{ se } \varphi_\alpha (\alpha) \uparrow \\
                    \varphi_\alpha (\alpha) + 1 & \text{ se } \varphi_\alpha (\alpha) \downarrow
                \end{cases}
                $$
                Ma tale funzione non può esistere: 
                \begin{itemize}
                    \item Nel primo caso $\varphi_\alpha (\alpha) = 0$ se $\varphi_\alpha (\alpha) \uparrow$, ma è una contraddizione
                    
                    \item Nel secondo caso $\varphi_\alpha (\alpha) = \varphi_\alpha (\alpha) + 1$, ma tale relazione non vale per nessun naturale
                \end{itemize}
                
                Siamo a un assurdo, $\ar$ è indecidibile. \\
            \end{proof}
        \end{solution}
        
        \question Sistemi di calcolo visti in Teoria della Calcolabilità.
        
        \begin{solution}
            I sistemi di calcolo visti sono: 
            \begin{itemize}
                \item Sistema $\ram$: infiniti registri, $R_0$ contiene l'output, $R_1$ l'input, si ha un program counter $L$, le istruzioni sono
                \begin{itemize}
                    \item Incremento: $R_k \leftarrow R_k + 1$
                    
                    \item Decremento: $R_k \leftarrow R_k \dotminus 1$
                    
                    \item Salto condizionato: \texttt{if} $R_k = 0$ \texttt{goto} $m$, con $m \in \left\{1, \dots, |P|\right\}$
                \end{itemize}
                
                \item Sistema $\while$: 21 registri, $x_0$ output, $x_1$ input, sono presenti dei comandi base: 
                \begin{itemize}
                    \item $x_k := x_j + 1$
                    
                    \item $x_k := x_j \dotminus 1$
                    
                    \item $x_k := 0$
                \end{itemize}
                e dei comandi definiti induttivamente:
                \begin{itemize}
                    \item Comando composto
                    \begin{center}
                        \texttt{begin} $C_1, \dots, C_n$ \texttt{end}
                    \end{center}
                    dove ogni $C_i$ è un qualsiasi comando
                    
                    \item Comando while
                    \begin{center}
                        \texttt{while} $x_k \neq 0$ \texttt{do} $C$
                    \end{center}
                    dove $C$ è un qualsiasi comando
                \end{itemize}
                Di conseguenza, un programma $\while$ è un comando composto
            \end{itemize}
        \end{solution}
        
        \question Approfondimento su RAM (struttura, istruzioni, stato prossimo, computazione)
        
        \begin{solution}
            Il sistema $\ram$ permette infiniti registri, tra i quali $R_0$ contiene l'output e $R_1$ l'input, si ha inoltre un program counter $L$ per tenere traccia dell'istruzione da eseguire. Un programma $P$ è un insieme ordinato di istruzioni. 
            
            Le istruzioni sono: 
            \begin{itemize}
                \item Incremento: $R_k \leftarrow R_k + 1$
                
                \item Decremento: $R_k \leftarrow R_k \dotminus 1$
                
                \item Salto condizionato: \texttt{if} $R_k = 0$ \texttt{goto} $m$, con $m \in \left\{1, \dots, |P|\right\}$
            \end{itemize}
            
            Ogni istruzione fa passare la macchina da uno stato a un altro; la semantica operazione di un'istruzione è formata dalla coppia degli stati prima e dopo l'istruzione.
            
            La computazione del programma $P$ è una sequenza di stati $\st_i$, infinita se non termina, altrimenti si ha uno stato finale $\st_{fin}$ in cui viene posto in $R_0$ il risultato della computazione.
            
            Lo stato è una funzione
            $$ \st: \left\{L, R_i\right\} \rightarrow \N $$
            ovvero, che dato un registro e un valore del program counter $L$, restituisce il contenuto del registro.
            
            Uno stato finale $\st_{fin}$ è un qualsiasi stato tale che $\st(L) = 0$.
            
            Lo stato iniziale è tale che
            $$ 
            \st_{init} (R_i) = \begin{cases}
                1 & \text{ se } R_i = L \\
                n & \text{ se } R_i = R_1 \\
                0 & \text{ altrimenti}
            \end{cases}
            $$
            
            Per definire l'esecuzione del programma si usa la funzione stato prossimo
            $$ \delta: \stati \times \prog \rightarrow \stati_\bot $$
            tale che 
            $$ \delta (\st, P) = \st'$$
            Dove $\st$ rappresenta lo stato in seguito all'esecuzione del comando $P$.
            
            La funzione è tale che: 
            \begin{itemize}
                \item Se $\st(L) = 0$, $\st' = \bot$ in quanto l'esecuzione è terminata
                
                \item Se $\st(L) > |P|$ non si ha una terminazione esplicita, quindi
                $$ \st' (R) = \begin{cases}
                    0 & \text{ se } R = L \\
                    \st(R_i) & \text{ altrimenti}
                \end{cases} $$
                
                \item Se $1 \leq \st (L) \leq |P|$, si considera l'istruzione $\st(L)$-esima:
                \begin{itemize}
                    \item incremento/decremento su $R_k$:
                    $$
                    \st' (R) = \begin{cases}
                        \st (R) + 1 & \text{ se } R = L \\ 
                        \st (R) \pm 1 & \text{ se } R = R_k \\
                        \st (R) & \text{ altrimenti}
                    \end{cases}
                    $$
                    
                    \item salto condizionato su $R_k$
                    $$
                    \st' (R) = \begin{cases}
                        m & \text{ se } R = L \wedge R_k = 0 \\
                        \st (L) + 1 & \text{ se } R = L \wedge R_k \neq 0 \\
                        \st (R) & \text{ altrimenti}
                    \end{cases}
                    $$
                \end{itemize}
            \end{itemize}
            
            L'esecuzione di un programma genera una sequenza di stati, definita secondo la funzione $\delta$.
        \end{solution}
        
        \question Struttura e istruzioni $\while$.
        
        \begin{solution}
            Il sistema di calcolo $\while$ usa esattamente 21 registri ed è strutturato, quindi non necessita di program counter. Sono presenti istruzioni base e istruzioni definite induttivamente. Comandi base: 
            \begin{itemize}
                \item $x_k := x_j + 1$
                
                \item $x_k := x_j \dotminus 1$
                
                \item $x_k := 0$
            \end{itemize}
            
            Comandi induttivi: 
            \begin{itemize}
                \item Comando composto
                \begin{center}
                    \texttt{begin} $C_1; \dots; C_n$ \texttt{end}
                \end{center}
                dove ogni $C_i$ è un qualsiasi tipo di comando
                
                \item Comando while
                \begin{center}
                    \texttt{while} $x_k \neq 0$ \texttt{do} $C$
                \end{center}
                dove $C$ è un qualsiasi comando
            \end{itemize}
            
            Per dimostrare proprietà di un programma $P \in \wprog$ la si verifica prima sui comandi base, poi induttivamente su comando composto e while.
            
            Dati comando da eseguire e stato corrente, la funzione stato prossimo restituisce lo stato successivo: 
            $$  \llbracket \_ \rrbracket ( \_ ): \wcom \times \wstati \rightarrow \wstati_\bot $$
            
            Si può definire la semantica induttivamente, a partire dagli assegnamenti: 
            $$
            \llbracket x_k := x_j \pm 1 \rrbracket (\underline{x}) = \begin{cases}
                x_i & \text{ se } i \neq k \\
                x_j \pm 1 & \text{ se } i = k
            \end{cases}
            $$
            $$
            \llbracket x_k := 0 \rrbracket (\underline{x}) = \begin{cases}
                x_i & \text{ se } i \neq k \\
                0 & \text{ se } i  = k
            \end{cases}
            $$
            Mentre per i comandi induttivi, partendo dal comando composto: 
            $$ \llbracket \text{\texttt{begin }} C_1; \dots; C_n \text{\texttt{ end}}\rrbracket (\underline{x}) = \left(\llbracket C_n \rrbracket \circ \dots \circ \llbracket C_1 \rrbracket \right) (\underline{x}) $$
            dove i comandi $C_i$ sono noti per I.H. 
            
            Per il comando while: 
            $$
            \llbracket \text{\texttt{while }} x_k \neq 0 \text{\texttt{ do }} C \rrbracket (\underline{x}) = \begin{cases}
                \llbracket C \rrbracket^e (\underline{x}) & \text{ se } \exists e \tc \llbracket C \rrbracket^e (\underline{x}) [k] = 0 \\
                \bot & \text{ altrimenti}
            \end{cases}
            $$
            
            Di conseguenza, dato che un programma while $W \in \wprog$ è un comando composto, si può rappresentare la semantica del programma come
            $$ \Psi_W (n) = \pro^{21}_0 \left(\llbracket W \rrbracket (\win(n))\right) $$
            dove $\win (n)$ restituisce lo stato iniziale della macchina con input $n$.
        \end{solution}
        
        \question Relazione tra $\ram$ e $\while$, con dimostrazione che il secondo è contenuto nel primo e viceversa.
        
        \begin{solution}
            Si può dimostrare che le funzioni calcolabili dai due sistemi sono le stesse, ovvero che $F(\ram) = F(\while)$. Per dimostrarlo si deve mostrare che $F(\while) \subseteq F(\ram)$ e $F(\ram) \subseteq F(\while)$.
            
            Dati due sistemi di calcolo $\C_1$ e $\C_2$, si definisce traduzione una funzione che associa i programmi di uno ai programmi dell'altro, con le proprietà di programmabilità, correttezza e completezza, rispetto ai programmi presenti nei due insiemi. Se esiste un traduttore da $\C_1$ a $\C_2$ allora $F(\C_1) \subseteq F(C_2)$, dato che per ogni programma $P_1$ del primo sistema di calcolo esiste (per completezza) $P_2 = t(P_1)$ nel secondo con la stessa semantica (per correttezza).
            
            Per dimostrare che $F(\while) \subseteq F(\ram)$, costruiamo un compilatore $C: \wprog \rightarrow \prog$. Si può definire induttivamente il compilatore, in quanto $\while$ è definito induttivamente. I 21 registri vengono mappati nei primi 21 $\ram$, dato che sono infiniti non ci sono problemi.
            
            Passo base: gli assegnamenti
            \begin{itemize}
                \item $x_k := 0$, si itera sul registro da azzerare finché è diverso da 0 (usando $R_{21} = 0$ come condizione di coda del ciclo)
                
                \item $x_k = x_j \pm 1$, se $k = j$ è banale, altrimenti bisogna
                \begin{itemize}
                    \item Spostare il valore di $R_j$ in $R_{22}$, azzerandolo
                    
                    \item Azzerare $R_k$
                    
                    \item Rigenerare $R_j$ e $R_k$ a partire da $R_{22}$
                    
                    \item Effettuare l'incremento/decremento effettivo
                \end{itemize}
            \end{itemize}
            
            Passo induttivo: 
            \begin{itemize}
                \item Il comando composto è una composizione di comandi noti per I.H.
                
                \item Il comando while si può compilare come un ciclo che esegue il comando, noto per I.H., finché $R_k \neq 0$
            \end{itemize}
            
            Il compilatore così definito è programmabile, compila ogni $W \in \wprog$ e mantiene la semantica, di conseguenza
            $$ F(\while) \subseteq F(\ram) $$
            
            Per mostrare che $F(\ram) \subseteq F(\while)$ vogliamo scrivere un interprete $I_W$ che prende in input un programma $P \in \prog$ e $x \in \N$ e restituisce l'esecuzione di $P$ su $x$, ovvero $\varphi_P (x)$. Non crea nulla di intermedio, si limita a eseguire il programma. 
            
            Dovendo prendere due input ($P$ e $x$), bisogna condensarli tramite Cantor, quindi, con $n = cod(P)$, l'input diventa $\langle x, n \rangle$. Di conseguenza: 
            $$ \forall x, n \in \N, \ \Psi_{I_W} (\langle x, n \rangle) = \varphi_n (x) = \varphi_P (x) $$
            
            Come salvare lo stato della macchina nell'interprete? Un problema sono i registri, in $\ram$ possono essere infiniti, ma non ne verranno mai usati veramente infiniti, quindi il contenuto di questi può essere rappresentato tramite una lista $\langle R_0, \dots, R_n \rangle$.
            
            L'interprete $I_W$ salva lo stato della macchina nel modo: 
            \begin{itemize}
                \item $x_0 \leftarrow \langle R_0, \dots, R_n \rangle$
                
                \item $x_1 \leftarrow L$
                
                \item $x_2 \leftarrow y$, dato su cui lavora $P$
                
                \item $x_3 \leftarrow n$, "listato" del codice
                
                \item $x_4 \leftarrow I$, istruzione attuale, prelevata dal listato grazie al PC
            \end{itemize}
            
            Inizialmente l'input $\langle x, n \rangle$ si trova in $x_1$. L'interprete deve quindi solamente estrarre, nell'ordine stabilito dal PC, le istruzioni dal listato, decodificare ed eseguirle, finché il PC è diverso da zero, ovvero $x_1 \neq 0$.
            
            Avendo l'interprete, si può costruire un compilatore $C: \prog \rightarrow \wprog$ semplicemente chiamando l'interprete dopo aver posto in $x_1$ l'input $\langle x_1, x_2 \rangle$, dove $x_1$ contiene l'input di $P$ e $x_2$ contiene $cod(P)$.
            
            Abbiamo quindi trovato un compilatore programmabile, completo e corretto da $\ram$ a $\while$, mostrando che
            $$ F(\ram) \subseteq F(\while) $$
            
            Di conseguenza
            $$ F(\ram) = F(\while) $$
        \end{solution}
        
        \question Differenza tra compilatore e interprete.
        
        \begin{solution}
            Un compilatore prende in input un programma e lo trasforma in un altro in un sistema di calcolo destinazione, mantenendone la semantica. 
            
            Un interprete è una funzione che prende come argomenti un programma e un input e simula l'esecuzione del programma passo passo, restituendo l'esecuzione del programma originale sull'input fornito.
        \end{solution}
        
        \question Come passare un programma $\ram$ all'interprete.
        
        \begin{solution}
            L'interprete accetta in input la codifica del programma (quindi un numero, dato che $\prog \sim \N$) e ricava l'istruzione da prelevare grazie al valore del PC, per poi decodificarla.
        \end{solution}
        
        \question Perché è impossibile che il destro di una coppia di Cantor sia 0, a meno che non sia l'ultima istruzione codificata.
        
        \begin{solution}
            Dopo aver applicato iterativamente Cantor su una lista $\langle x_1, \langle \dots \langle x_n, 0 \rangle \dots \rangle \rangle$, quando vengono estratti i valori, come $\sin$ verrà estratto l'ultimo valore inserito, come $\des$ rimarrà la codifica di tutti gli altri valori della lista, che quindi potrà essere 0 solo nel caso in cui questa è l'ultima istruzione codificata.
        \end{solution}
        
        \question Gerarchia classi di complessità e descrizione.
        
        \begin{solution}
            Le classi di complessità sono
            $$ L \subseteq P \subseteq NP \subseteq \exptime \subseteq \cp $$
            E sono definite come:
            \begin{itemize}
                \item $L = \dspace \left(\log n\right)$
                
                \item $P = \dtime \left(n^k \right)$
                
                \item $NP = \ntime \left(n^k \right)$
                
                \item $\exptime = \dtime \left(2^{n^k}\right)$
                
                \item $\cp$ tutte le funzioni calcolabili
            \end{itemize}
        \end{solution}
        
        \question Descrizione DTM per calcolare lo spazio.
        
        \begin{solution}
            Data la DTM $M = (Q, \Sigma, \Gamma, \delta, q_0, F)$ si definisce $S(x)$ il numero di celle occupate sul nastro di memoria durante la computazione di $M$ su $x$. 
            
            La complessità in spazio viene conseguentemente definita come
            $$ s(x) = \max \left\{S (x) \mid x \in \Sigma^\ast \wedge |x| = n\right\}$$ 
            ovvero come il massimo numero di celle usate per il calcolo di un input, per ogni taglia di input.
            
            Ma in questo modo viene considerato anche lo spazio dedicato all'input, non permettendo complessità sublineari. Per risolvere, si aggiunge un altro nastro dedicato all'input, con dei terminatori $\notin \Sigma$. Si deve modificare la funzione di transizione per gestire il moto delle due testine e permettere di leggere sia da nastro di input che di lavoro.
            
            Per ogni $x \in \Sigma^\ast$, $S(x)$ è ora dato solo dal numero di celle usate solamente sul nastro di lavoro, non considerando così l'interferenza dovuta all'input.
            
            Il linguaggio $L \in \Sigma^\ast$ è riconosciuto in spazio deterministico $f(n)$ se e solo se esiste una DTM $M$ tale che $L = L_M$ e $s(n) \leq f(n)$.
        \end{solution}
        
        \question Com'è definita la computazione in una DTM.
        
        \begin{solution}
            La computazione è una sequenza di mosse (passo che, dato lo stato corrente e simbolo letto, porta a un nuovo stato, con eventuale scrittura e spostamento) dettate dalla funzione di transizione. 
            
            La funzione di transizione è definita come
            $$ \delta: Q \times \Gamma \rightarrow Q \times (\Gamma \setminus \left\{ blank \right\}) \times \left\{-1, 0, 1\right\} $$
        \end{solution}
        
        \question Qual è la condizione di terminazione in una DTM.
        
        \begin{solution}
            Una DTM termina quando entra in uno stato finale, ovvero con $\delta (q, \gamma) = \bot$, oppure quando la funzione di transizione non è definita (si tratta di una funzione parziale).
        \end{solution}
        
        \question Definizione ricorsive primitive partendo da $\elem$.
        
        \begin{solution}
            L'insieme $\elem$ contiene solo le operazioni di successore, proiettore e azzeramento. Aggiungendo l'operatore di composizione 
            $$ \comp (h, g_1, \dots, g_k): \N^n \rightarrow \N \mid \comp (h, g_1, \dots, g_k) (\underline{x}) = h(g_1 (\underline{x}) \circ \dots \circ g_n (\underline{x})) $$
            e l'operatore di ricorsione primitiva
            $$ \rp (h, g) = f(\underline{x}, y) = \begin{cases}
                g(\underline{x}) & \text{ se } y = 0 \\
                h(f(\underline{x}, y), y-1, \underline{x}) & \text{ se } y > 0 
            \end{cases}$$
            per poi chiudere l'insieme rispetto alle due operazioni, si ottiene l'insieme $\ricprim$
            $$ \elem^{\left\{\comp, \rp\right\}} = \ricprim $$
        \end{solution}
        
        \question Definizione ricorsive parziali. Come abbiamo definito le funzioni calcolabili?
        
        \begin{solution}
            A partire da $\ricprim$ (definito sopra), per aggiungere all'insieme delle funzioni calcolabili le ricorsive parziali si usa l'operatore di minimalizzazione: 
            $$ \MIN (f) (\underline{x}) = \mu_y (f(\underline{x}, y) = 0) = \begin{cases}
                y & \text{se } f(\underline{x}, y) = 0 \wedge (\forall y' < y, f(\underline{x}, y) \downarrow \wedge f(\underline{x}, y') \neq 0) \\
                \bot & \text{altrimenti}
            \end{cases} $$
            
            Informalmente, restituisce il più piccolo valore di $y$ che azzera $f(\underline x, y)$, ovunque precedentemente definita su $y'$. Questo operatore permette le presenza di funzioni parziali e chiudere $\ricprim$ rispetto alla minimalizzazione permette di ottenere
            $$ \elem^{\left\{\comp, \rp, \MIN\right\}} = \cp $$
            ovvero l'insieme delle funzioni ricorsive parziali.
        
            La tesi di Church-Turing sostiene che l'insieme delle funzioni intuitivamente calcolabili coincide con $\cp$ (alternativamente, le funzioni calcolabili tramite DTM).
        \end{solution}
        
        % TODO ????
        \question $\ricprim = F(\for)$
        
        \begin{solution}
            Tutte le funzioni in $\ricprim$ hanno inizio e fine ben definiti, sono tutte funzioni totali (ma non rappresenta tutte le funzioni totali), quindi sulla base di questo si può definire il costrutto $\for$ che si serve di una variabile di controllo che parte da un valore ed arriva a un valore limite. 
            
            Le funzioni calcolabili tramite $\for$ sono funzioni totali con numero di iterazioni noto, esattamente come per $\ricprim$.
        \end{solution}
        
        \question Relazione tra $\cp$ e $F(\while)$.
        
        \begin{solution}
            Per confrontare $\cp$ e $F(\while)$ si può cominciare dal domandarsi se $\cp \subseteq F(\while)$. L'insieme $\cp$ può essere visto come definito induttivamente, ovvero
            \begin{itemize}
                \item Se $f \in \elem$ allora $f \in \cp$
                
                \item Se $h, g_1, \dots, g_k \in \cp$ allora $\comp(h, g_1, \dots, g_k) \in \cp$
                
                \item Se $h, g \in \cp$ allora $\rp(h,g) \in \cp$ 
                
                \item Se $f \in \cp$, allora $\MIN (f) \in \cp$
            \end{itemize}
            
             Di conseguenza, proviamo per induzione strutturale su $\cp$ che le funzioni sono while-programmabili: 
            \begin{itemize}
                \item Passo base: le funzioni elementari sono semplicemente programmabili tramite while
                
                \item Passi induttivi: 
                \begin{itemize}
                    \item Per $\comp (h,g_1, \dots, g_k) \in \cp$: si tratta di una composizione di istruzioni base, programmabili per I.H.
                    
                    \item Per $\rp (h, g) = f(\underline{x}, y)$: si usa un comando while e una variabile di controllo per iterare un singolo comando, programmabile per I.H., finché la variabile di controllo non ha raggiunto il valore di $y$
                    
                    \item Per $\MIN(f) \in \cp$: un ciclo while può incrementare il valore di 1 finché non azzera la funzione, ottenendo la stessa semantica della minimalizzazione
                \end{itemize}
            \end{itemize}
            Quindi $\cp \subseteq F(\while)$.
            
            Per $F(\while) \subseteq \cp$: si può rappresentare la semantica di un programma $W \in \wprog$ con 
            $$ \Psi_W = \pro^{21}_0 (\llbracket W \rrbracket (\win (x))) $$
            Quindi, sapendo che l'operatore di proiezione è $\in \cp$, se la funzione di stato prossimo è ricorsiva parziale abbiamo verificato l'inclusione. 
            
            Definiamo la funzione numero prossimo $f_C$ che applica Cantor all'array degli stati; si può passare da $\llbracket C \rrbracket (x)$ a $f_C (x)$ usando solo funzioni ricorsive parziali. Verifichiamo che $f_C$ sia ricorsiva parziale per induzione strutturale: 
            \begin{itemize}
                \item Passo base:
                
                \begin{itemize}
                    \item $C \equiv x_k :=0$
                    $$ f_C = \left[ \pro^{21}_0 (x), \dots, 0, \dots, \pro^{21}_20 (x) \right] $$
                    con lo 0 in posizione $k$
                    
                    \item $C \equiv x_k := x_j \pm 1$
                    $$ f_C = \left[\pro^{21}_0 (x), \dots, \pro^{21}_j (x) + 1, \dots, \pro^{21}_20 (x) \right] $$
                \end{itemize}
                Avendo usato solo funzioni $\in \cp$, i due comandi sono $\in \cp$
                
                \item Passo induttivo: 
                \begin{itemize}
                    \item $C \equiv \text{\texttt{begin }} C_1; \dots; C_n; \text{\texttt{ end}}$
                    $$ f_C = f_{C_n} ( \dots f_{C_1}(x) \dots )$$
                    
                    \item $C \equiv \text{\texttt{while }} x_k \neq 0 \text{\texttt{ do }} C_b$
                    $$ f_C (x) = f_{C_b}^{e(x)} (x) \text{ con } e(x) = \mu_y (\pro(k, f_{C_b}^y (x))) $$
                    $e(x)$ non è costante, ma si può definire $T(x,y) = f_{C_b}^y (x)$, facilmente implementabile tramite ricorsione primitiva, quindi $\in \cp$, facendo diventare $e(x)$ una minimalizzazione di funzioni $\in \cp$, quindi $e(x) \in \cp$. 
                \end{itemize}
                Quindi anche questi sono $\in \cp$
            \end{itemize}
            Abbiamo provato anche che $F(\while) \in \cp$.
            
            Di conseguenza, in totale
            $$ \cp = F(\while) $$ 
        \end{solution}
        
        \question Perché ha senso il corso di informatica teorica? Perché ha senso studiare la teoria della calcolabilità?
        
        \begin{solution}
            \sout{Perché mi servono credit} Il corso si pone le domande di \textit{cosa} è in grado di fare l'informatica e \textit{come} è in grado di farlo.
            
            La teoria della calcolabilità vuole dare una caratterizzazione generale, sotto forma matematica, di ciò che è calcolabile, ovvero i problemi risolvibili per via automatica. Ha l'obiettivo di delineare la portata dell'informatica stessa.
        \end{solution}
        
        \question Definire la potenza di calcolo.
        
        \begin{solution}
            La potenza di calcolo di un sistema è definita come l'insieme di tutte le funzioni che quel sistema è in grado di calcolare.
            
            Definendo un sistema di calcolo come 
            $$ \C: \prog \rightarrow \dati, \text{ con } P \in \prog \tc P: \dati \rightarrow \dati_\bot $$
            Con $\C(P,x)$ si indica la semantica del programma $P$ su input $x$ nel sistema di calcolo $\C$, ovvero il risultato dell'esecuzione.
            
            La potenza di calcolo è quindi definita come
            $$ F(\C) = \left\{\C(P, \_) \mid P \in \prog \right\} $$
        \end{solution}
        
        \question Cosa significa che $\N$ non è isomorfo a $\N_\bot^\N$?
        
        \begin{solution}
            Quando due insiemi sono isomorfi vuol dire che si può avere una biezione tra essi, $\N$ è "meno numeroso" di $\N_\bot^\N$, di conseguenza non si può avere una biezione.
            
            Per dimostrarlo: per assurdo, supponiamo che $\N \sim \N_\bot^\N$, ovvero entrambi gli insiemi sono numerabili e di conseguenza listabili. Ricordando la definizione
            $$ \N_\bot^\N = \left\{f: \N \rightarrow \N_\bot \right\} $$
            
            Possiamo listare tutte le funzioni: 
            \begin{itemize}
                \item Sulla prima riga $f_0(0)$, $f_0(1)$, $f_0(2)$, \dots
                
                \item Sulla seconda riga $f_1(0)$, $f_1(1)$, $f_1(2)$, \dots
                
                \item \dots
            \end{itemize}
            
            Costruiamo una funzione $\varphi: \N \rightarrow \N_\bot$ tale che
            $$ \varphi (x) = \begin{cases}
                1 & \text{ se } f_x(x) = \bot \\
                f_x(x) + 1 & \text{ se } f_x(x) \downarrow
            \end{cases}$$
            Questa funzione appartiene a $\N_\bot^\N$ ma non alla lista definita precedentemente, assurdo sotto l'assunzione che $\N_\bot^\N$, di conseguenza
            $$ \N_\bot^\N \nsim \N $$
        \end{solution}
        
        \question Quali sono le funzioni in $\elem$?
        
        \begin{solution}
            Le funzioni all'interno di $\elem$ sono
            \begin{center}
                \begin{tabular}{r c r l c l}
                    $\elem = $ & $\{$ & successore: & $s(x) = x + 1$, & $x \in \N$ & \\
                    && zero: & $0^n (x_1, \dots, x_n) = 0$, & $x_i \in \N$ & \\
                    && proiettori: & $\pro_k^n (x_1, \dots, x_n) = x_k$, & $x_i \in \N$& $\}$ \\
                \end{tabular}
            \end{center}
            
            Queste sono funzioni "basilari" che qualunque idea di calcolabilità deve considerare come calcolabili.
        \end{solution}
        
        \question Operatore di composizione, operatore di ricorsione primitiva. Quale è il nome dell'insieme ottenuto dopo la ricorsione primitiva?
        
        \begin{solution}
            L'operatore di composizione è definito come
            $$ \comp (h, g_1, \dots, g_k) (\underline{x}) = h(g_1 (\underline{x}) \circ \dots \circ g_k (\underline{x})) $$
            
            L'operatore di ricorsione primitiva è definito come
            $$
            \rp(h,g) = f(\underline{x}, y) = \begin{cases}
                g(\underline{x}) & \text{ se } y = 0 \\
                h(f(\underline{x}, y-1), y-1, \underline{x}) & \text{ se } y > 0 
            \end{cases}
            $$
            
            Chiudendo l'insieme $\elem$ rispetto alle operazioni di composizione e ricorsione primitiva si ottiene
            $$ \elem^{\left\{\comp, \rp\right\}} = \ricprim $$
        \end{solution}
        
        \question $\ricprim \subseteq F(\while)$
        
        \begin{solution}
            Per dimostrare che $\ricprim \subseteq F(\while)$ consideriamo una definizione induttiva di $\ricprim$, questo è definibile come
            \begin{itemize}
                \item Se $f \in \elem$, $f \in \ricprim$
                
                \item Se $h,g_1, \dots, g_k \in \ricprim$, $\comp(h, g_1, \dots, g_k) \in \ricprim$
                
                \item Se $h,g \in \ricprim$, $\rp (h,g) \in \ricprim$
                
                \item Nient'altro in $\ricprim$
            \end{itemize}
            
            Di conseguenza mostrare per induzione strutturale che ognuno di questi punti è while-programmabile permette di verificare l'inclusione.
            
            Passo base: le funzioni $\in \elem$ sono banalmente $\in \wprog$.
            
            Passo induttivo:
            \begin{itemize}
                \item La composizione di funzioni è un susseguirsi di comandi base, $\in \wprog$ per I.H., di conseguenza implementabile in $\while$
                
                \item La ricorsione primitiva è una forma di iterazione definita (implementabile tramite comando while e una variabile di controllo) che esegue un comando, quest'ultimo $\in \wprog$ per I.H.
            \end{itemize}
            
            Di conseguenza abbiamo verificato che
            $$ \ricprim \subseteq F(\while) $$
        \end{solution}
        
        \question Operatore di minimalizzazione.
        
        \begin{solution}
            L'operatore di minimalizzazione consiste, informalmente, del più piccolo valore che permette di azzerare una funzione, ovunque precedentemente definita. 
            
            Formalmente
            $$ \MIN (f) (\underline{x}) = \begin{cases}
                y & \text{se } f(\underline{x}, y) = 0 \wedge (\forall y' < y, f(\underline{x}, y') \neq 0 \wedge f(\underline{x}, y') \downarrow) \\
                \bot & \text{altrimenti}
            \end{cases}$$
        \end{solution}
        
        \question Dimostrare $F(\while) \subseteq \cp$.
        
        \begin{solution}
            Per dimostrare che $F (\while) \subseteq \cp$ bisogna mostrare che la semantica di ogni programma $\in \wprog$ è esprimibile sotto forma di operazioni $\in \cp$. 
            
            Sapendo che un programma while  $W$ è definibile come funzione stato prossimo sul programma stesso, la semantica su input $x$ è esprimibile come
            $$ \Psi_W = \pro_0^{21} \llbracket W \rrbracket (\win (x)) $$
            Dove: 
            \begin{itemize}
                \item La funzione $\llbracket C \rrbracket (x)$ restituisce lo stato della macchina in seguito all'esecuzione del comando $C$ (una tupla)
                
                \item $\pro_0^{21}$ restituisce il valore del primo registro (quello di output), a partire dalla tupla contenente lo stato della macchina
                
                \item $\win(x)$ definisce lo stato iniziale della macchina con input $x$
            \end{itemize}
            
            Di conseguenza, mostrando che la funzione di stato prossimo è ricorsiva parziale viene verificata l'inclusione. 
            
            Il primo problema è che $\llbracket \_ \rrbracket (\_)$ lavora su $\N^{21}$, mentre gli elementi di $\cp$ hanno codominio $\N$. Per risolvere viene definita la funzione "numero prossimo" $f_C$, che condensa lo stato della macchina in un singolo valore tramite Cantor (useremo notazione $\left[\_\right]$).
            
            Vogliamo quindi mostrare che $f_C \in \cp$. Lo si può fare per induzione strutturale: 
            \begin{itemize}
                \item Passo base: assegnamenti:
                \begin{itemize}
                    \item $C \equiv x_k := 0$
                    $$ f_C (x) = \left[\pro (0, x), \dots, 0, \dots, \pro (20, x) \right] $$
                    dove lo 0 è in posizione $k$
                    
                    \item $C \equiv x_k := x_j \pm 1$
                    $$ f_C (x) = \left[\pro (0, x), \dots, \pro (j, x) \pm 1, \dots, \pro(20, x) \right] $$
                    sempre lavorando sulla posizione $k$
                \end{itemize}
                Si può notare che, per ora, $f_C$ è composta da solo funzioni $\in \cp$
                
                \item Passo induttivo:
                \begin{itemize}
                    \item $C \equiv \text{\texttt{begin }} C_1; \dots; C_k; \text{\texttt{ end}}$
                    $$ f_C (x) = f_{c_k}( \dots f_{C_1}(x) \dots) $$
                    
                    \item $C \equiv \text{\texttt{while }} x_k \neq 0 \text{ do } C_b$
                    $$ f_C (x) = f_{C_b}^{e(x)} (x) \ \text{ con } \ e(x) = \mu_y (\pro (k, f_{C_b}^y (x)) = 0) $$
                    ma $e(x)$ non è costante. Si può definire però $ T(x,y) = f_{C_b}^y (x) $, implementabile tramite ricorsione primitiva:
                    $$ T(x, y) = \begin{cases}
                        x & \text{ se } y = 0 \\
                        f_{C_b} (T (x, y-1)) & \text{ se } y > 0
                    \end{cases}$$
                    
                    Di conseguenza $T(x,y) \in \T$, quindi
                    $$ e(x) = \mu_y (\pro (k, f_{C_b}^y (x)) = 0) = \mu_y (\pro (k, T(x,y)) = 0) \in \T $$
                    
                    In conclusione
                    $$ f_C (x) = T(x, e(x))$$
                    quindi anche questo rientra $\in \cp$
                \end{itemize}
            \end{itemize}
        \end{solution}
        
        \question SPA.
        
        \begin{solution}
            Un Sistema di Programmazione Accettabile SPA è un sistema di calcolo $\C$ che rispetta gli assiomi di Rogers, ovvero
            \begin{enumerate}
                \item Aderisce alla tesi di Church-Turing
                $$ F(\C) = \cp $$
                
                \item Ammette interprete universale
                $$ \exists u \in \N \tc \forall x,y \in \N, \ \varphi_u (\langle x,y \rangle) = \varphi_y (x) $$
                
                \item Rispetta il teorema $S^m_n$, ovvero esiste $S^m_n \in \T$ tale che
                $$ \forall n \in \N, \underline{x} \in \N^m, \underline{y} \in \N^n, \ \varphi_n (\langle \underline{x}, \underline{y} \rangle) = \varphi_{S^m_n (n, \underline{y})} (\underline{x}) $$
            \end{enumerate}
        \end{solution}
    \end{questions}
\end{document}
